[{"title":"js验证身份证","date":"2017-08-08T02:02:49.000Z","path":"2017/08/08/js验证身份证/","text":"身份证校验国家身份证校验规则：前六位为行政区域代码、中间八位为出生年月信息、三位为顺序码(通常奇数为男偶数为女)、最后一位为校验码（通过数学计算方式得出） 计算方法 身份证前17位① 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 2^17 2^16 2^15 2^14 2^13 2^12 2^11 2^10 2^9 2^18 2^7 2^6 2^5 2^4 2^3 2^2 2^1 除于 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 ÷11 余数② 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 ①*② 7 18 30 20 40 24 14 8 54 3 14 27 40 25 48 28 26 ①*②的和= 425÷11 余数 = 7 余数列表 0 1 2 3 4 5 6 7 8 9 10 校验码列表 1 0 X 9 8 7 6 5 4 3 2 所以身份证12345678912345678的最后一位校验码为5 最后一位可能出现的X并不是英文字母Ｘ，而是希腊数字10的缩写X","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"校验","slug":"校验","permalink":"http://yoursite.com/tags/校验/"}]},{"title":"Oracle学习笔记——创建用户、表空间、权限控制以及用户授权","date":"2017-07-20T03:55:53.000Z","path":"2017/07/20/Oracle学习笔记——创建用户、表空间、权限控制以及用户授权/","text":"–(system root )as sysdba–查询所有用户select username from dba_users; –查询用户对应的表空间select username,default_tablespace,temporary_tablespace from dba_users where username=&apos;ORACLE&apos;; –查询用户对应的表空间对应的表select owner,table_name,tablespace_name from dba_tables where owner=&apos;ROOT&apos;; –查询用户的角色select * from dba_role_privs a where a.grantee=&apos;ROOT&apos;; —查询角色对应的权限select ROLE, PRIVILEGE from role_sys_privs where role=&apos;RESOURCE&apos;; –查询某个用户具有的系统权限select grantee,privilege from dba_sys_privs where grantee=&apos;ROOT&apos;; select * from all_tables where owner=&apos;MDSYS&apos;; –回收Scott的RESOURCE角色revoke RESOURCE from root; revoke connect from scott; —授权RESOURCE、connect角色的权限grant connect,RESOURCE to scott; –oracle查询表空间文件所在路径select * from dba_data_files; –new user pwd (root root) default tablespace ROOT–创建表空间CREATE TABLESPACE ROOT logging datafile &apos;E:\\app\\*****\\oradata\\orcl\\root.dbf&apos; size 50M autoextend on next 5M maxsize 500M extent management local; –创建用户设置默认表空间create user root identified by root default tablespace root temporary tablespace temp; grant connect,RESOURCE to root; –删除用户drop user root cascade; –====================================================================–(new user root root) as normal––建表create table STUDENT( sid varchar2(10), sname varchar2(10), address varchar2(255), phone number, idCard varchar2(20), course_id varchar2(10) ); –主键alter table student add constraint Primary_key_sid primary key (sid); select * from base_user t; select * from student;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"Mybatis中关于OGNL表达式冲突的问题","date":"2017-07-06T01:16:23.000Z","path":"2017/07/06/Mybatis中关于OGNL表达式冲突的问题/","text":"项目中遇到一个问题在用mybatis写SQL语句的时候，因为需求需要动态SQL，其中有个字段是审核人简称为shr，shr会与与mybatis的OGNL表达式发生冲突导致SQL语法报错。 变量命名可能发生冲突的变量集合bor (字符|)的英文 xor 字符^的英文 and 字符&amp;&amp; band 字符&amp; eq 字符== neq 字符！= lt 字符&lt; gt 字符&gt; lte 字符&lt;= gte 字符&gt;= shl 字符 &lt;&lt; shr 字符&gt;&gt; ushr 字符&gt;&gt;&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"MyBatis，OGNL","slug":"MyBatis，OGNL","permalink":"http://yoursite.com/tags/MyBatis，OGNL/"}]},{"title":"Druid数据源使用介绍","date":"2017-06-12T07:25:52.000Z","path":"2017/06/12/Druid数据源使用介绍/","text":"Druid数据源使用介绍Druid介绍DruidDataSource是一个数据库连接池的实现，它的设计目标是提供一个当前最好的数据库连接池，在性能、扩展性等方面取得最合适的平衡。Druid能够提供强大的监控和扩展功能。 DruidDataSource配置&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init- method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc_url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc_user}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc_password}&quot; /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &apos;x&apos;&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt; &lt;/bean&gt; 通常来说，只需要修改initialSize、minIdle、maxActive。如果用Oracle，则把poolPreparedStatements配置为true，mysql可以配置为false。分库分表较多的数据库，建议配置为false。 使用Druid的内置监控页面Druid内置提供了一个StatViewServlet用于展示Druid的统计信息。 这个StatViewServlet的用途包括： 提供监控信息展示的html页面 提供监控信息的JSON API 配置： &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 根据配置中的url-pattern来访问内置监控页面，如果是上面的配置，内置监控页面的首页是/druid/index.html 例如：http://127.0.0.1:8090/platform/druid/index.html 检查数据库连接泄漏当程序存在缺陷时，申请的连接忘记关闭，这时候，就存在连接泄漏了。Druid提供了RemoveAbandanded相关配置，用来关闭长时间不使用的连接。例如： &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; ... ... &lt;property name=&quot;removeAbandoned&quot; value=&quot;true&quot; /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;1800&quot; /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name=&quot;logAbandoned&quot; value=&quot;true&quot; /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; ... ... &lt;/bean&gt; 当removeAbandoned=true之后，可以在内置监控界面中查看ActiveConnection StackTrace属性的，可以看到未关闭连接的具体堆栈信息，从而方便查出哪些连接泄漏了。 附：Druid官方wiki","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"连接池","slug":"连接池","permalink":"http://yoursite.com/tags/连接池/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"MyBatis注入方式注意${}和#{}的区别","date":"2017-05-24T00:53:59.000Z","path":"2017/05/24/MyBatis注入方式注意-和-的区别/","text":"项目中遇到一个问题用Oracle的to_char(${arg},’yyyy-MM-dd’)的时候,方法传来一个时间参数，但是查不到任何结果，看了控制台打印的SQL语句没有发现任何问题，复制到PL/Sql developer 测试运行一下也不行。 解决询问了一下别人才知道，原来${arg}这种注入方式的参数是直接取对象的值不经过转义，用#{arg}注入会转义变成响应的类型 用${}传入数据直接显示在生成的sql中，如上面的语句，用 role_id =${roleId,jdbcType=INTEGER},那么sql在解析的时候值为role_id = roleid，执行时会报错; ${}方式无法防止sql注入; $一般用入传入数据库对象，比如数据库表名; 能用#{}时尽量用#{}; 注意mybaties排序时使用order by 动态参数时需要注意，使用${}而不用#{};","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"注入","slug":"注入","permalink":"http://yoursite.com/tags/注入/"}]},{"title":"Oracle日期中的IW和WW的区别","date":"2017-05-24T00:42:11.000Z","path":"2017/05/24/Oracle日期中的IW和WW的区别/","text":"WWww是按照年份的第一天(2017-01-01)开始的，不管是不是星期一都是按照第一周计算。 IWIW 是按照普通历法的计算方法计算周数，每年必须包含 52 或者53 周 如果52周后到12月31号剩余四天以上，则为本年的53周，如果52周后到12月31日不满四天，则算到下一年的第一周 用法to_char(to_date(&apos;2017/02/03&apos;,&apos;yyyy-MM-dd&apos;),&apos;yyyyww&apos;) to_char(to_date(&apos;2017/02/03&apos;,&apos;yyyy-MM-dd&apos;),&apos;yyyyiw&apos;) to_date(&apos;2017-02-03&apos;,&apos;yyyyww&apos;) to_date(&apos;2017-02-03&apos;,&apos;yyyyiw&apos;)","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"},{"name":"日期","slug":"日期","permalink":"http://yoursite.com/tags/日期/"}]},{"title":"MySql按周，按月，按日分组统计数据","date":"2017-05-15T03:18:10.000Z","path":"2017/05/15/MySql按周，按月，按日分组统计数据/","text":"select DATE_FORMAT(create_time,&apos;%Y%u&apos;) weeks,count(caseid) count from tc_case group by weeks; select DATE_FORMAT(create_time,&apos;%Y%m%d&apos;) days,count(caseid) count from tc_case group by days; select DATE_FORMAT(create_time,&apos;%Y%m&apos;) months,count(caseid) count from tc_case group by months; DATE_FORMAT(date,format)根据format 字符串格式化date值，修饰符如下 修饰符 描述 %M 月名字(January……December) %W 星期名字(Sunday……Saturday) %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。) %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(Sun……Sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(Jan……Dec) %j 一年中的天数(001……366) %H 小时(00……23) %k 小时(0……23) %h 小时(01……12) %I 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [AP]M) %T 时间,24 小时(hh:mm:ss) %S 秒(00……59) %s 秒(00……59) %p AM或PM %w 一个星期中的天数(0=Sunday ……6=Saturday) %U 星期(0……52), 这里星期天是星期的第一天 %u 星期(0……52), 这里星期一是星期的第一天 %% 一个文字“%”。 销售统计SELECT year(payment_date), sum(CASE month(payment_date) WHEN 01 THEN amount END) &apos;一月份销售额&apos;, sum(CASE month(payment_date) WHEN 02 THEN amount END) &apos;二月份销售额&apos;, sum(CASE month(payment_date) WHEN 03 THEN amount END) &apos;三月份销售额&apos;, sum(CASE month(payment_date) WHEN 04 THEN amount END) &apos;四月份销售额&apos;, sum(CASE month(payment_date) WHEN 05 THEN amount END) &apos;五月份销售额&apos;, sum(CASE month(payment_date) WHEN 06 THEN amount END) &apos;六月份销售额&apos;, sum(CASE month(payment_date) WHEN 07 THEN amount END) &apos;七月份销售额&apos;, sum(CASE month(payment_date) WHEN 08 THEN amount END) &apos;八月份销售额&apos;, sum(CASE month(payment_date) WHEN 09 THEN amount END) &apos;九月份销售额&apos;, sum(CASE month(payment_date) WHEN 10 THEN amount END) &apos;十月份销售额&apos;, sum(CASE month(payment_date) WHEN 11 THEN amount END) &apos;十一月份销售额&apos;, sum(CASE month(payment_date) WHEN 12 THEN amount END) &apos;十二月份销售额&apos; from payment group by year(payment_date); 查询一天，查询一周，查询一个月的数据 查询一天 select from table where to_days(column_time) = to_days(now()); 结果可能会不准确 select from table where date(column_time) = curdate(); 查询一周 select * from table where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(column_time); 查询一个月 select * from table where DATE_SUB(CURDATE(), INTERVAL 1 MONTH) &lt;= date(column_time); 查询上个月每天的数据统计 select DATE_FORMAT(FROM_UNIXTIME(createDate/1000),’%m月%d日’)as date, count(id) from cm_user_detail where date_format(FROM_UNIXTIME(createDate/1000),’%Y-%m’) = date_format(date_sub(curdate(), interval 1 month),’%Y-%m’) group by date 查询本月每天的数据统计 select DATE_FORMAT(FROM_UNIXTIME(createDate/1000),’%m月%d日’)as date, count(id) from cm_user_detail where date_format(FROM_UNIXTIME(createDate/1000),’%Y-%m’) = date_format(date_sub(curdate(), interval 0 month),’%Y-%m’) group by date","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"},{"name":"日期转换","slug":"日期转换","permalink":"http://yoursite.com/tags/日期转换/"}]},{"title":"ExcelUtils","date":"2017-05-03T01:47:36.000Z","path":"2017/05/03/注解ExcelUtils/","text":"ExcelUtilspublic class ExcelUtils { /** * 为单元格设值 * * @param hs 工作区对象 * @param row 单元格所在行数 * @param col 单元格所在列数 * @param value 设置的值 */ public static void setValue(Sheet hs, int row, int col, String value) { setValue(hs, row, col, value, null); } /** * 为单元格设值 * * @param style 单元格样式对象 */ public static void setValue(Sheet hs, int row, int col, String value, CellStyle style) { Row hr = hs.getRow(row) == null ? hs.createRow(row) : hs.getRow(row); Cell hc = hr.getCell(col) == null ? hr.createCell(col) : hr.getCell(col); if (null != style) { hc.setCellStyle(style); } hc.setCellValue(value); } /** * 为单元格设值，同时给单元格添加边框。 * * @param wb 单元格所在excel对象 * @param hs 单元格所在工作区对象 * @param row 单元格所在行数 * @param col 单元格所在列数 * @param value 设置的值 */ public static void setValueWithBorder(Workbook wb, Sheet hs, int row, int col, String value) { setValueWithBorder(wb, hs, row, col, value, null); } /** * 为单元格设值，同时给单元格添加边框。 * * @param style 单元格样式对象 */ public static void setValueWithBorder(Workbook wb, Sheet hs, int row, int col, String value, CellStyle style) { Row hr = hs.getRow(row) == null ? hs.createRow(row) : hs.getRow(row); Cell hc = hr.getCell(col) == null ? hr.createCell(col) : hr.getCell(col); CellStyle cs; if (null != style) { cs = style; } else { cs = wb.createCellStyle(); } setCsBorder(cs); hc.setCellStyle(cs); hc.setCellValue(value); } /** * 为单元格设值，同时给单元格添加边框。 * * @param wb * @param hs * @param row * @param col * @param value */ public static void setValueWithColor(Workbook wb, Sheet hs, int row, int col, String value) { Row hr = hs.getRow(row) == null ? hs.createRow(row) : hs.getRow(row); Cell hc = hr.getCell(col) == null ? hr.createCell(col) : hr.getCell(col); CellStyle cs; cs = wb.createCellStyle(); setCsBorder(cs); Font font = wb.createFont(); font.setColor(Font.COLOR_RED); cs.setFont(font); hc.setCellStyle(cs); hc.setCellValue(value); } /** * 给单元格设置边框 * * @param cs */ public static void setCsBorder(CellStyle cs) { cs.setBorderBottom(CellStyle.BORDER_THIN); cs.setBorderLeft(CellStyle.BORDER_THIN); cs.setBorderRight(CellStyle.BORDER_THIN); cs.setBorderTop(CellStyle.BORDER_THIN); } /** * 给单元格设值 * * @param cell 单元格对象 * @param value 设置的值 */ public static void setCellValue(Cell cell, Object value) { if (value == null) { return; } if (value instanceof Long || value instanceof Integer || value instanceof Double) { cell.setCellValue(Double.valueOf(String.valueOf(value))); } else { cell.setCellValue(String.valueOf(value)); } } /** * 调用此方法，直接下载到客户端 * * @param response * @param fileName */ public static void download(HttpServletResponse response, Workbook workbook, String fileName) throws FileNotFoundException, SecurityException, IllegalArgumentException, IOException, NoSuchMethodException, IllegalAccessException, InvocationTargetException { response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=\\&quot;&quot; + new String(fileName.getBytes(&quot;gb2312&quot;), &quot;iso8859-1&quot;) + &quot;\\&quot;&quot;); response.setContentType(&quot;APPLICATION/msexcel&quot;); OutputStream out = response.getOutputStream(); workbook.write(out); out.close(); } /** * 从url读出excel */ public static Workbook loadWorkbook(String filePath) throws FileNotFoundException, IOException { InputStream inputStream = new FileInputStream(filePath); boolean isExcel = filePath.toLowerCase().endsWith(&quot;xls&quot;) ? true : false; Workbook workbook = isExcel ? new HSSFWorkbook(inputStream) : new XSSFWorkbook(inputStream); return workbook; } /** * 把excel保存到磁盘 */ public static void saveToHarddisk(String url, Workbook workbook) throws IOException { BufferedOutputStream bo = new BufferedOutputStream(new FileOutputStream(url)); workbook.write(bo); bo.close(); } /** * 合并单元格 * * @param sheet * @param startRow 开始单元格所在行 * @param startCol 开始单元格所在列 * @param endRow 结束单元格所在行 * @param endCol 结束单元格所在列 */ public static void mergeRegion(Sheet sheet, int startRow, short startCol, int endRow, short endCol, CellStyle cs) { CellRangeAddress address = new CellRangeAddress(startRow, endRow, startCol, endCol); sheet.addMergedRegion(address); if (cs != null) { setRegionStyle(sheet, address, cs); } } private static void setRegionStyle(Sheet sheet, CellRangeAddress cellRangeAddress, CellStyle cs) { for (int i = cellRangeAddress.getFirstColumn(); i &lt;= cellRangeAddress.getLastColumn(); i++) { Row row = sheet.getRow(i) == null ? sheet.createRow(i) : sheet.getRow(i); for (int j = cellRangeAddress.getFirstColumn(); j &lt;= cellRangeAddress.getLastColumn(); j++) { Cell cell = row.getCell(j) == null ? row.createCell(j) : row.getCell(j); cell.setCellStyle(cs); } } } /** * 创建样式 * * @param workbook * @param color */ public static CellStyle createFCStyle(Workbook workbook, short color) { CellStyle style = workbook.createCellStyle(); Font fort = workbook.createFont(); fort.setColor(color); style.setFont(fort); return style; } /** * 拷贝excel区域 * * @param wb * @param sourceSheetIndex * @param pTargetSheetIndex * @param pStartRow * @param pEndRow * @param pPosition */ public static void copyRows(Workbook wb, int sourceSheetIndex, int pTargetSheetIndex, int pStartRow, int pEndRow, int pPosition) { Sheet sourceSheet = wb.getSheetAt(sourceSheetIndex); Sheet targetSheet = wb.getSheetAt(pTargetSheetIndex); copyRows(wb, sourceSheet, targetSheet, pStartRow, pEndRow, pPosition); } /** * 拷贝excel区域 * * @param wb * @param pSourceSheetName 源sheet * @param pTargetSheetName 目标sheet * @param pStartRow 开始行 * @param pEndRow 结束行 * @param pPosition 目标sheet的开始行 */ public static void copyRows(Workbook wb, String pSourceSheetName, String pTargetSheetName, int pStartRow, int pEndRow, int pPosition) { Sheet sourceSheet = wb.getSheet(pSourceSheetName); Sheet targetSheet = wb.getSheet(pTargetSheetName); copyRows(wb, sourceSheet, targetSheet, pStartRow, pEndRow, pPosition); } /** * 拷贝excel区域 */ private static void copyRows(Workbook wb, Sheet sourceSheet, Sheet targetSheet, int pStartRow, int pEndRow, int pPosition) { Row sourceRow = null; Row targetRow = null; Cell sourceCell = null; Cell targetCell = null; CellRangeAddress region = null; int cType; int i; int j; int targetRowFrom; int targetRowTo; if ((pStartRow == -1) || (pEndRow == -1)) { return; } // 拷贝合并的单元格 for (i = 0; i &lt; sourceSheet.getNumMergedRegions(); i++) { region = sourceSheet.getMergedRegion(i); if ((region.getFirstRow() &gt;= pStartRow) &amp;&amp; (region.getLastRow() &lt;= pEndRow)) { targetRowFrom = region.getFirstRow() - pStartRow + pPosition; targetRowTo = region.getLastRow() - pStartRow + pPosition; region.setFirstRow(targetRowFrom); region.setLastRow(targetRowTo); targetSheet.addMergedRegion(region); } } // 设置列宽 for (i = pStartRow; i &lt;= pEndRow; i++) { sourceRow = sourceSheet.getRow(i); if (sourceRow != null) { for (j = sourceRow.getLastCellNum(); j &gt;= sourceRow.getFirstCellNum(); j--) { targetSheet.setColumnWidth(j, sourceSheet.getColumnWidth(j)); targetSheet.setColumnHidden(j, false); } break; } } // 拷贝行并填充数据 for (; i &lt;= pEndRow; i++) { sourceRow = sourceSheet.getRow(i); if (sourceRow == null) { continue; } targetRow = targetSheet.createRow(i - pStartRow + pPosition); targetRow.setHeight(sourceRow.getHeight()); for (j = sourceRow.getFirstCellNum(); j &lt; sourceRow.getPhysicalNumberOfCells(); j++) { sourceCell = sourceRow.getCell(j); if (sourceCell == null) { continue; } targetCell = targetRow.createCell(j); // targetCell.setEncoding(sourceCell.getEncoding()); targetCell.setCellStyle(sourceCell.getCellStyle()); cType = sourceCell.getCellType(); targetCell.setCellType(cType); switch (cType) { case Cell.CELL_TYPE_BOOLEAN: targetCell.setCellValue(sourceCell.getBooleanCellValue()); break; case Cell.CELL_TYPE_ERROR: targetCell.setCellErrorValue(sourceCell.getErrorCellValue()); break; case Cell.CELL_TYPE_FORMULA: targetCell.setCellFormula(parseFormula(sourceCell.getCellFormula())); break; case Cell.CELL_TYPE_NUMERIC: targetCell.setCellValue(sourceCell.getNumericCellValue()); break; case Cell.CELL_TYPE_STRING: targetCell.setCellValue(sourceCell.getRichStringCellValue()); break; } } } } private static String parseFormula(String pPOIFormula) { final String cstReplaceString = &quot;ATTR(semiVolatile)&quot;; //$NON-NLS- StringBuffer result = null; int index; result = new StringBuffer(); index = pPOIFormula.indexOf(cstReplaceString); if (index &gt;= 0) { result.append(pPOIFormula.substring( index)); result.append(pPOIFormula.substring(index + cstReplaceString.length())); } else { result.append(pPOIFormula); } return result.toString(); } public static String getCellStringValue(Cell cell) { return getCellStringValue(cell, null); } public static String getCellStringValue(Cell cell, DecimalFormat decimalFormat) { DecimalFormat df = decimalFormat == null ? new DecimalFormat(&quot;#&quot;) : decimalFormat; String text = &quot;&quot;; // 判断单元格的类别,并且全部转换成String 类型 switch (cell.getCellType()) { case 0: // Numeric text = StringUtils.trimToEmpty(df.format(cell.getNumericCellValue())); break; case 1: // String text = StringUtils.trimToEmpty(cell.getStringCellValue()); default: text = StringUtils.trimToEmpty(cell.getStringCellValue()); break; } return text; } public static void main(String[] args) { try { InputStream inputStream = new FileInputStream(&quot;d:\\\\test.xls&quot;); Workbook wb = true ? new HSSFWorkbook(inputStream) : new XSSFWorkbook(inputStream); //source ,target 为,源sheet 页和目标sheet页, // copyRows(wb, &quot;Sheet, &quot;Sheet, ; // wb.cloneSheet(; // wb.setSheetName( &quot;Sheet); setValue(wb.getSheetAt(0), 5, 5, &quot;ddd&quot;); setValueWithBorder(wb, wb.getSheetAt(0), 5, 8, &quot;ddd2&quot;); FileOutputStream fileOut = new FileOutputStream(&quot;d:\\\\testxls&quot;); wb.write(fileOut); fileOut.flush(); fileOut.close(); System.out.println(&quot;Operation finished&quot;); } catch (Exception e) { e.printStackTrace(); } } public static String cellToString(Cell cell) { if (cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC) { return String.valueOf(cell.getNumericCellValue()); } else if (cell.getCellType() == HSSFCell.CELL_TYPE_BOOLEAN) { return String.valueOf(cell.getBooleanCellValue()); } else if (cell.getCellType() == HSSFCell.CELL_TYPE_FORMULA) { return String.valueOf(cell.getCellFormula()); } else { return cell.getStringCellValue(); } } /** * 读取 excel */ public static &lt;T&gt; List&lt;T&gt; readExcel(Class&lt;T&gt; clazz, String fileName, InputStream is) throws Exception { String extension = fileName.lastIndexOf(&quot;.&quot;) == -1 ? &quot;&quot; : fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1); // 构造 Workbook 对象 Workbook workbook = null; if (&quot;xls&quot;.equals(extension)) { // workbook = new HSSFWorkbook(is); } else if (&quot;xlsx&quot;.equals(extension)) { // workbook = new XSSFWorkbook(is); } else { throw new IOException(&quot;不支持的文件类型&quot;); } // 读取第一页表格 Sheet sheet = workbook.getSheetAt(0); Object value = null; Row row = null; Cell cell = null; int counter = 0; //列名、字段 Map&lt;String, String&gt; columnMap = new HashMap(); Field[] fields = getBeanFields(clazz, new Field[]{}); for (Field f : fields) { ExcelAnnotation annotation = f.getAnnotation(ExcelAnnotation.class); if (annotation != null) { if (!columnMap.containsKey(annotation.columnName())) columnMap.put(annotation.columnName(), f.getName()); } } //格式化器 DecimalFormat df = new DecimalFormat(&quot;0&quot;);// 格式化 number String SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);// 格式化日期字符串 DecimalFormat nf = new DecimalFormat(&quot;0.00&quot;);// 格式化数字 //临时变量 T t = null; //结果列表 List&lt;T&gt; resultList = new ArrayList&lt;T&gt;(); //行，从第二行开始 for (int i = 1; i &lt;= sheet.getLastRowNum(); i++) { row = sheet.getRow(i); if (row == null) { continue; } else { counter++; } t = clazz.newInstance(); //列， for (int j = 0; j &lt;= row.getLastCellNum(); j++) { cell = row.getCell(j); if (cell == null) { continue; } switch (cell.getCellType()) { case XSSFCell.CELL_TYPE_STRING: value = cell.getStringCellValue(); break; case XSSFCell.CELL_TYPE_NUMERIC: if (&quot;@&quot;.equals(cell.getCellStyle().getDataFormatString())) { value = df.format(cell.getNumericCellValue()); } else if (&quot;General&quot;.equals(cell.getCellStyle().getDataFormatString())) { value = nf.format(cell.getNumericCellValue()); } else { value = sdf.format(HSSFDateUtil.getJavaDate(cell.getNumericCellValue())); } break; case XSSFCell.CELL_TYPE_BOOLEAN: value = cell.getBooleanCellValue(); break; case XSSFCell.CELL_TYPE_BLANK: value = &quot;&quot;; break; default: value = cell.toString(); } if (value == null || &quot;&quot;.equals(value)) { continue; } // 第二个参数通过标题获取属性名 String columnName = sheet.getRow(0).getCell(j).toString(); org.apache.commons.beanutils.BeanUtils.setProperty(t, columnMap.get(columnName), value); } resultList.add(t); } return resultList; } private static Field[] getBeanFields(Class clazz, Field[] fs){ fs = (Field[]) ArrayUtils.addAll(fs, clazz.getDeclaredFields()); if(clazz.getSuperclass()!=null){ Class clsSup = clazz.getSuperclass(); fs = getBeanFields(clsSup, fs); } return fs; } } ExcelAnnotation@Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到 @Target({ElementType.FIELD}) public @interface ExcelAnnotation { /** * 列名 * * @return */ String columnName() default &quot;&quot;; }","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/工具类/"}]},{"title":"angularjs基本学习笔记","date":"2017-03-17T06:46:36.000Z","path":"2017/03/17/angularjs基本学习笔记/","text":"更新时间 2017-3-17 表达式双大括号表示{{model}} 通过$interpolateProvider的配置来更换表示符号 var Myapp=angualr.module(&apos;Myapp&apos;,[]) .config(function($interpolateProvider){ $interpolateProvider.startSymbol(&apos;[[&apos;).endSymbol(&apos;]]&apos;); }); 表达式就可以更换为 [[model]] 基本指令ng-app=&quot;myApp&quot;定义一个名字为myApp的应用程序，这个指令使用在标 签当中，标签开始到结束就是改App的应用范围。 ng-controller指令定义了应用程序控制器，一些事件和操作写在里面。 一个js文件的基本格式Var myApp=angular.module(&apos;myApp&apos;,[]); myApp.config(function(){ ......... }); myApp.filter(&apos;filter&apos;,function(){ ................... }); myApp.controller(&apos;myController&apos;,function($scope,$http){ function init(){ ...................... } init(); }) 依赖注入有5个核心组件作为依赖注入 value factory service provider constant 例子 valuevar app=angular.module(&apos;app&apos;,[]); app.value(&apos;name&apos;,5); name=5 factoryfactory作为一个函数的返回值 mainApp.factory(&apos;MathService&apos;, function() { var factory = {}; factory.multiply = function(a, b) { return a * b } return factory; }); service// 在 service 中注入 factory &quot;MathService&quot; mainApp.service(&apos;CalcService&apos;, function(MathService){ this.square = function(a) { return MathService.multiply(a,a); } }); 在Controller调用这些服务mainApp.controller(&apos;CalcController&apos;, function($scope, CalcService, defaultInput) { $scope.number = defaultInput; $scope.result = CalcService.square($scope.number); $scope.square = function() { $scope.result = CalcService.square($scope.number); } }); Provider也可以定义factory和ServicemainApp.config(function($provide) { $provide.provider(&apos;MathService&apos;, function() { this.$get = function() { var factory = {}; factory.multiply = function(a, b) { return a * b; } return factory; }; }); }); constantconstant(常量)用来在配置阶段传递数值，注意这个常量在配置阶段是不可用的。 mainApp.constant(&quot;configParam&quot;, &quot;constant value&quot;);","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"关于在angularjs中使用jQuery的ajax异步请求回调函数不刷新model的问题","date":"2017-03-06T14:58:02.000Z","path":"2017/03/06/关于在angularjs中使用jQuery的ajax异步请求回调函数不刷新model的问题/","text":"问题最近项目页面用到angularjs，没学过就仿造里面自带的例子就上手了项目开发，按照里面的写法刚开始还很好使，但是用着用着还是会有些地方 会用上jQuery的东西，其中就有ajax的异步请求，后台功能写好了以后测试提交发现页面无法显示model的值，虽然进入了回调函数值也有了，但 是页面显示不出来，等第二次提交的时候才会显示出来，于是我猜是两个问题： 可能处于不同的域 model没有刷新 然后仔细看了一下域是同一个页面也不是什么对象也没有用其他会产生子域的angular指令，所以域是相同的 后来百度了一下果然不止我一个人有这个问题，其中原因就是用jQuery的ajax回调造成不刷新的问题 解决办法$scope.$apply(); 或者 $scope.$apply(function (){ ....你变更的数据 }); Scope提供$watch方法监视Model的变化。 Scope提供$apply方法传播Model的变化。 Scope可以继承，用来隔离不同的application components和属性访问权限。 Scope为Expressions的计算提供上下文。 $apply()实际上是由scope.digest()完成的，但是我们几乎从来就没有直接调用过这个方法，而是调用scope.apply()方法， 是因为在scope.apply()方法里面，它会去调用scope.digest()方法。scope.apply()方法带一个函数或者一个表达式，然后执行它，最后调用 scope.digest()方法去更新bindings或者watchers。 相关文章相关–angularJS中$apply()方法详解 相关– 理解Angular中的$apply()以及$digest() Understanding Angular’s $apply() and $digest()","categories":[{"name":"问题","slug":"问题","permalink":"http://yoursite.com/categories/问题/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"},{"name":"问题","slug":"问题","permalink":"http://yoursite.com/tags/问题/"},{"name":"jQuery ajax","slug":"jQuery-ajax","permalink":"http://yoursite.com/tags/jQuery-ajax/"}]},{"title":"第一次搭建Hexo+Github个人博客","date":"2017-03-05T02:51:22.000Z","path":"2017/03/05/第一次搭建Hexo+Github个人博客/","text":"你好，欢迎来到个人博客。搭建方法用github账户新建一个仓库，命名为：username.github.io默认安装node.js 打开cmdnode -v npm -v 安装git任意路径任意名字新建文件夹进入新建文件夹打开git Bash 命令行窗口输入命令:npm install hexo -g 输入命令hexo init 生成静态页面hexo generate 本地启动hexo server 浏览器输入 http://localhost:4000 修改 _config.yml 输入命令vim _config.yml 去到最后一行修改你的github仓库地址deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 执行命令npm install hexo-deployer-git --save 执行命令hexo deploy 访问你的github仓库地址yourname.github.io","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://yoursite.com/tags/奇淫技巧/"},{"name":"配置","slug":"配置","permalink":"http://yoursite.com/tags/配置/"}]},{"title":"Hello World","date":"2017-03-05T02:51:22.000Z","path":"2017/03/05/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Hexo使用","slug":"Hexo使用","permalink":"http://yoursite.com/tags/Hexo使用/"},{"name":"开始","slug":"开始","permalink":"http://yoursite.com/tags/开始/"}]}]